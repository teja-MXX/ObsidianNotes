# ğŸ“¦ Containerization

- Containerization packages and runs applications in **isolated environments** called containers.
- Ensures **consistent behavior** across different systems/environments.
- Popular technologies:
  - `Docker`
  - `Docker Compose`
  - `LXC (Linux Containers)`

## âš–ï¸ Containers vs Virtual Machines

- Containers share the **host system's kernel**, unlike VMs.
- **Lightweight** and more **efficient** than virtual machines.
- Quick to **create**, **deploy**, and **manage**.
- Ideal for:
  - **Microservices**
  - **Scalability**
  - **Portability**
  - 
## ğŸ›ï¸ Flexibility & Scalability

- Containers are **highly configurable**.
- Multiple containers can run on the same host.
- Great for:
  - Running **microservices**
  - **Scaling** applications horizontally

## ğŸ¤ Real-World Analogy

> Imagine organizing a concert:
> - Each band gets a **self-contained stage pod** (container) with their setup.
> - All pods use the **same main stage** (host system).
> - Easy to move, isolated from each other, and work the same in any venue.
>  
> Just like containers: portable, isolated, consistent.

## ğŸ” Security in Containers

- Containers provide **isolation** from:
  - Host system
  - Other containers
- Benefits:
  - Reduces risk of **malicious interference**
  - Adds **an extra layer of protection**
- Limitations:
  - Not as isolated as VMs
  - Possible risks:
    - **Privilege escalation**
    - **Container escape**
- Requires proper:
  - **Configuration**
  - **Hardening**

## ğŸš€ Deployment & Portability

- Containers include:
  - App
  - Libraries
  - Dependencies
- Ensures **consistency** across:
  - Development
  - Testing
  - Production
- Makes deployment and management **faster** and **easier**

## âš ï¸ Note

> Containers are **not immune to security risks**.  
> Improperly configured containers may allow **escalation** or **isolation breakouts**.

# ğŸ³ Docker

- Docker is an **open-source platform** for automating the deployment of applications using **containers**.
- Containers are **self-contained units** that package:
  - Code
  - Libraries
  - Dependencies

---

## ğŸ”§ Key Features

- **Layered filesystem** for efficient storage and updates
- **Resource isolation** (CPU, memory, network, etc.)
- Offers tools for:
  - **Creating**
  - **Deploying**
  - **Managing** containers

---

## ğŸ¯ Why Docker?

- Simplifies and streamlines **containerization**
- Ensures **portability** across different systems
- Great for **DevOps**, **CI/CD pipelines**, and **microservice architectures**

---

## ğŸ± Analogy: The Sealed Lunchbox

> - Docker containers are like **sealed lunchboxes**  
> - You can eat the food (run the app), and once closed (stopped), the contents reset  
> - To update the contents, create a new **recipe (Dockerfile)**  
> - Running a restaurant? Use a **kitchen system** like Kubernetes or Docker Compose to manage many lunchboxes (containers)

---

## ğŸ“‚ Key Docker Components

- `Dockerfile` â€“ Blueprint for building container images
- `Docker Image` â€“ Read-only template to create containers
- `Docker Container` â€“ Running instance of an image
- `Docker Hub` â€“ Registry for sharing images

---

## ğŸš€ Use Cases

- Consistent environments for development/testing
- Quick deployments in production
- Isolation without the overhead of full virtual machines

## ğŸ³ Docker Engine & Images

- To run a container, you need:
  - **Docker Engine**
  - A specific **Docker Image** which can be obtained from Docker Hub

---

## ğŸ“¦ Docker Hub

- **Docker Hub** is a cloud-based registry for Docker images.
- It includes:
  - ğŸ”“ **Public area**:
    - Share images with the community
    - Includes official images (e.g., Ubuntu, Nginx)
  - ğŸ” **Private area**:
    - For internal sharing (e.g., within teams or companies)

---

## ğŸ› ï¸ Creating a Docker Image

- Create a `Dockerfile` to define:
  - Base image
  - Packages to install
  - Commands to run
- The `Dockerfile` is used by Docker Engine to **build** the image.

---

## ğŸ“‚ Use Case: File Hosting Server in Docker

- You can use Docker containers as a **file-hosting server** for file transfer purposes.
- Ideal tools included:
  - **Apache HTTP Server** (for `curl`, `wget`, etc.)
  - **OpenSSH Server** (for `scp` file transfers)

---

## ğŸ§¾ Example Dockerfile (Ubuntu 22.04 with Apache + SSH)

```dockerfile
FROM ubuntu:22.04

RUN apt update && apt install -y \
    apache2 \
    openssh-server \
    curl \
    wget \
    net-tools

# Enable and start SSH and Apache
CMD service apache2 start && service ssh start && bash
```

- After we have defined our Dockerfile, we need to convert it into an image.
- With theÂ `build`Â command, we take the directory with the Dockerfile, execute the steps from theÂ `Dockerfile`, and store the image in our local Docker Engine.
- If one of the steps fails due to an error, the container creation will be aborted. With the optionÂ `-t`, we give our container a tag, so it is easier to identify and work with later.

## Docker Build

```bash
tejaM20@htb[/htb]$ docker build -t FS_docker .
```
- Once a **Docker image** is created, it can be run using the **Docker engine**.
- Containers are similar to **virtual machines**, but more lightweight.
- **Docker images**:
  - Are **read-only templates**
  - Include the **filesystem** and **runtime parameters** needed
- A **container** is:
  - A **running instance** of a Docker image
- If the image is not found locally:
  - Docker **downloads it** from Docker Hub (or other registry)
	- To start a container, use: docker run command

## Docker Run - Syntax
```bash
tejaM20@htb[/htb]$ docker run -p <host port>:<docker port> -d <docker container name>
```

## Docker Run
```bash
tejaM20@htb[/htb]$ docker run -p 8022:22 -p 8080:80 -d FS_docker
```

- Starts a new container from the imageÂ `FS_docker`
- map the host ports 8022 and 8080 to container ports 22 and 80, respectively.
- The container runs in the background, allowing us to access the SSH and HTTP services inside the container using the specified host ports.

## Docker Management
- Docker provides a  suite of tools that enable us to easily 
	- Create
	- Deploy 
	- And manage containers
- With these powerful tools, we can effectively manage them, ensuring seamless execution of applications
- Some of the most commonly used Docker management commands are

| Command          | Description                   |
| ---------------- | ----------------------------- |
| `docker ps`      | List all running containers   |
| `docker stop`    | Stop a running container.     |
| `docker start`   | Start a stopped container.    |
| `docker restart` | Restart a running container.  |
| `docker rm`      | Remove a container.           |
| `docker rmi`     | Remove a Docker image.        |
| `docker logs`    | View the logs of a container. |
- ğŸ§± **Docker containers are stateless** â€“ Changes made inside a container are lost when it's stopped or removed unless data is persisted using volumes.
- ğŸ“¦ **Docker images are immutable** â€“ Changes to running containers are **not** saved to the original image. You must build a new image to preserve updates.
- ğŸ“„ **Dockerfile is used to build images** â€“ Start with a `FROM` statement and define steps to configure the image.
- ğŸ› ï¸ **Use `docker build` to create images** â€“ This command reads the Dockerfile and builds a new image with a tag.
- ğŸ”§ **Docker commands accept various options** â€“ You can expose ports, mount volumes, or set environment variables for flexibility.
- ğŸ’¾ **Use volumes to persist data** â€“ Helps retain data across container restarts or removals.
- ğŸ“Š **Use orchestration tools for production** â€“ Tools like Docker Compose or Kubernetes help manage containers at scale.

# Linux Containers (LXC)

- ğŸ§© **LXC** is a lightweight virtualization method that uses Linux kernel features (like **cgroups** and **namespaces**) to create isolated environments.
- âš™ï¸ Containers **share the host kernel**, making them more resource-efficient than traditional virtual machines.
- ğŸ› ï¸ LXC provides **tools and APIs** for managing Linux containers but may require more manual setup.

## Docker vs LXC: Key Differences

| **Category**     | **Docker**                                                                 | **LXC**                                                                 |
|------------------|-----------------------------------------------------------------------------|-------------------------------------------------------------------------|
| **Approach**     | Application-focused, optimized for packaging and deploying apps.            | System-level, behaves like lightweight VMs.                             |
| **Image building**| Uses standardized Docker images (self-contained).                          | Requires more manual configuration.                                     |
| **Portability**  | Highly portable using Docker Hub and registries.                            | Less portable; tightly linked to host system.                           |
| **Ease of use**  | User-friendly CLI, simple for beginners, wide community support.            | Requires deeper Linux admin knowledge.                                  |
| **Security**     | Strong isolation with AppArmor/SELinux, read-only FS by default.            | Secure, but needs more manual configuration for strong isolation.       |

> ğŸ’¡ **Note:** Both Docker and LXC can be misconfigured, potentially allowing **privilege escalation** if not handled securely.

## Creating an LXC Container

To create a new LXC container, we can use theÂ `lxc-create`Â command followed by the container's name and the template to use. For example, to create a new Ubuntu container namedÂ `linuxcontainer`, we can use the following command:
```bash
tejaM20@htb[/htb]$ sudo lxc-create -n linuxcontainer -t ubuntu
```

## Managing LXC Containers

- When working with LXC containers, several tasks are involved in managing them. 
- These tasks include 
	- creating new containers, 
	- configuring their settings, 
	- starting and stopping them as necessary, 
	- monitoring their performance. 
### ğŸ§¾ LXC Command Cheat Sheet

| **Command**                                                | **Description**                                         |
|------------------------------------------------------------|---------------------------------------------------------|
| `lxc-ls`                                                   | List all existing containers.                           |
| `lxc-start -n <container>`                                 | Start a stopped container.                              |
| `lxc-stop -n <container>`                                  | Stop a running container.                               |
| `lxc-restart -n <container>`                               | Restart a running container.                            |
| `lxc-config -n <container name> -s storage`                | Manage container storage.                               |
| `lxc-config -n <container name> -s network`                | Manage container network settings.                      |
| `lxc-config -n <container name> -s security`               | Manage container security settings.                     |
| `lxc-attach -n <container>`                                | Connect to a container (like attaching to a shell).     |
| `lxc-attach -n <container> -f /path/to/share`              | Attach and share a specific directory or file.          |

> ğŸ’¡ Replace `<container>` with the actual container name in all commands.

## ğŸ§ª Using Linux Containers (LXC) for Penetration Testing

- ğŸ§± **Linux containers** are lightweight, standalone environments that package software with all dependencies (code, libraries, config).
- ğŸ” They run **consistently across any Linux system**, regardless of the host's configuration.
- ğŸš€ Ideal for pentesters needing to test apps or systems with **complex dependencies** or **specific setups**.

### ğŸ¯ Benefits in Penetration Testing

- âœ… **Quick setup** of isolated environments tailored for testing.
- ğŸ§ª **Exploit or malware testing** in controlled containers (e.g., simulate a vulnerable system).
- âš™ï¸ Avoids the need for manual system configuration.
- ğŸ’¡ Use exact versions of databases, web servers, or other dependencies.

### ğŸ” LXC Container Security Tips

- ğŸ”’ **Restrict access** to the container.
- ğŸ§¯ **Limit resource usage** to avoid abuse.
- ğŸŒ **Isolate from the host system** to prevent breakout.
- ğŸ›¡ï¸ **Enforce Mandatory Access Control (MAC)** using tools like AppArmor or SELinux.
- ğŸ”„ **Keep the container updated** with latest patches and fixes.

> âš ï¸ Proper security configuration is essential to safely use containers for exploit or malware testing.

## ğŸ” Securing LXC Containers

### ğŸ”‘ Access Control

- Containers can be accessed via **SSH**, **console**, etc.
- ğŸ”’ Best practices:
  - **Disable unnecessary services**.
  - Use **secure protocols**.
  - Enforce **strong authentication**.
- ğŸ›‘ To disable SSH access:
  - Remove the `openssh-server` package, or
  - Configure SSH to **only allow trusted IPs**.

---

### ğŸ§® Resource Control with cgroups

- Containers share the **host kernel** and its resources.
- Use **resource limits/quotas** to prevent overuse.
- Example: Limit CPU & memory via `cgroups`.

```bash
# Create container config file
sudo vim /usr/share/lxc/config/linuxcontainer.conf

lxc.cgroup.cpu.shares = 512
lxc.cgroup.memory.limit_in_bytes = 512M
```

#### ğŸ§  Key Parameters:
- `lxc.cgroup.cpu.shares`:
    - Controls the **CPU time share**.
    - Default = `1024` (full share).
    - `512` = half the CPU time compared to default.
        
- `lxc.cgroup.memory.limit_in_bytes`:
    - Sets **maximum memory** container can use.
    - Supports units: `B`, `K`, `M`, `G`, `T`.

ğŸš€ Apply changes:
```bash
sudo systemctl restart lxc.service
```
### ğŸ§± Isolation via Namespaces

- **Namespaces** isolate:
    - Processes (`pid`) 
    - Networks (`net`)
    - File systems (`mnt`)
- Each container:
    - Has **its own PID namespace**â€”can't interfere with host processes.
    - Gets **isolated network stack**â€”interfaces, routing, firewall.
    - Uses a **separate root file system**â€”changes inside don't affect the host.
        

> ğŸ›¡ï¸ Note: Namespaces provide strong isolation but **not full security**. Always combine with additional hardening!

# ğŸ§ª Optional Hands-on Exercises for LXC

1. [ ] ğŸ§° Install LXC and create your first container.
2. [ ] ğŸŒ Configure container network settings.
3. [ ] ğŸ§± Create and launch a custom LXC image.
4. [ ] ğŸ“‰ Apply CPU, memory, and disk resource limits.
5. [ ] ğŸ”§ Explore various `lxc-*` commands.
6. [ ] ğŸŒ Launch a web server container (e.g., Apache, Nginx).
7. [ ] ğŸ” Set up and test SSH access to the container.
8. [ ] ğŸ’¾ Create a container with persistence.
9. [ ] ğŸ’£ Use LXC to test vulnerable apps or malware in isolation.
