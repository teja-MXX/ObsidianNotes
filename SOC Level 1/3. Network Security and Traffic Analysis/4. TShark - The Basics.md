# 🧪 Command-Line Packet Analysis Hints

## 📄 What is TShark?

**TShark** is the command-line version of Wireshark. It is especially useful for:
- ✅ Text-based and automated analysis
- 🔍 In-depth packet inspection
- ⚙️ Integration with other command-line tools for **scripting and automation**

TShark is **powerful** because it allows **pipelining** data into and from other CLI tools, making it a favorite for SOC and DFIR analysts.

## 🛠️ Common Command-Line Tools for Packet Analysis

| **Tool / Utility** | **Purpose and Benefit** |
|--------------------|-------------------------|
| `capinfos`         | Provides a **summary** of a capture file. Great for understanding the scope of data before diving in. |
| `grep`             | Used to **search** through plain-text output (e.g., for IPs, strings, protocols). |
| `cut`              | Extracts specific **fields** or characters from lines. Useful when processing structured output. |
| `uniq`             | Filters and shows **unique values**. Often used after `sort` to remove duplicates. |
| `nl`               | Adds **line numbers** to output. Helpful for navigation and scripting. |
| `sed`              | A **stream editor** for text substitution, insertion, deletion, and pattern-based editing. |
| `awk`              | A **powerful scripting language** for pattern scanning, text processing, and field extraction. |

## 📌 Pro Tip: Basic Workflow Example

```bash
tshark -r traffic.pcap | grep "HTTP" | cut -d " " -f 3 | sort | uniq -c
```

This one-liner:
- Loads a PCAP
- Filters for HTTP lines
- Extracts the 3rd field (e.g., URL paths or methods)
- Sorts them
- Shows unique values with counts

## 🚀 Why Use CLI Tools?

- CLI tools are **fast** and **lightweight**
- Ideal for **headless environments** (e.g., remote servers)
- Excellent for **automation and scripting**
- Easy to **combine with cron jobs**, **SIEM input**, or **log enrichment**

## 📚 Summary

> Using TShark and related CLI tools can drastically improve your incident response and traffic analysis workflow. With practice, you’ll be able to perform deep insights without even opening a GUI.

---
# 🧪 Command-Line Interface and Parameters (TShark)

## 📄 Overview

**TShark** is a powerful command-line tool for packet analysis. It allows **deep inspection** of packet captures and **live traffic sniffing** through terminal commands.

To use TShark efficiently, it’s essential to understand its most common **parameters**. These parameters help you **control output**, **filter noise**, and **extract relevant data** during investigations.

## ⚙️ Commonly Used Parameters

| **Parameter** | **Purpose** | **Example** |
|---------------|-------------|-------------|
| `-h`          | Display the help page listing common features and flags. | `tshark -h` |
| `-v`          | Show version info of the TShark installation. | `tshark -v` |
| `-D`          | List all **available interfaces** for sniffing. | `tshark -D` |
| `-i`          | Choose a specific **interface** to capture live traffic from. | `tshark -i 1` <br> `tshark -i ens55` |
| *(none)*      | Without any parameter, TShark defaults to sniffing from the **first** interface. | `tshark` |

## 🕵️‍♂️ Sniffing with TShark

### 🔍 What is Sniffing?

**Sniffing** refers to the monitoring of **network traffic** passing through a network interface. It is essential for:

- Network diagnostics
- Incident response
- Threat detection

### 🧵 Interface Selection

TShark allows traffic capture on **any available interface**. Some examples include:

- Ethernet (e.g., `eth0`, `ens55`)
- Wi-Fi (e.g., `wlan0`)
- Loopback (e.g., `lo`)

### 🛠 How to Sniff

#### 🟢 Default Sniff (first interface)
```bash
tshark
```

#### 🟢 Specify interface manually

```bash
tshark -i 1 tshark -i eth0
```

#### 🟢 List interfaces to select from

```bash
tshark -D
```

## 🔐 Permissions Note
TShark **requires superuser (root) privileges** to:
- Sniff live traffic
 - List interfaces using `-D`
- Run commands with `sudo` when needed.

```bash
sudo tshark -i eth0
```

## 📌 Summary

- TShark is a command-line alternative to Wireshark.
- It excels in **automated**, **scripted**, and **remote** traffic analysis.
- Mastering its parameters (especially `-D`, `-i`, and `-h`) helps analysts streamline their investigations.

---
# 🧪 Command-Line Interface and Parameters II (TShark)

## 📄 Overview

This section continues exploring essential **TShark parameters** that enhance your command-line packet analysis workflow. These options are especially helpful when working with **PCAP files**, **writing filtered packets**, or **dumping detailed packet information** for further investigation.

## ⚙️ Additional TShark Parameters

| **Parameter** | **Purpose** | **Example** |
|---------------|-------------|-------------|
| `-r` | **Read** a capture file (PCAP/PCAPNG). | `tshark -r demo.pcapng` |
| `-c` | **Capture/read only X packets**. Useful for limiting output. | `tshark -c 10` |
| `-w` | **Write** filtered/sniffed packets to file (PCAP). | `tshark -w sample-capture.pcap` |
| `-V` | **Verbose mode.** Show full packet detail like Wireshark's Packet Details Pane. | `tshark -V` |
| `-q` | **Quiet mode.** Suppress packet output on terminal. | `tshark -q` |
| `-x` | **Hex/ASCII dump** of each packet. | `tshark -x` |

## 📂 Read Capture Files

Use the `-r` parameter to read a saved **PCAP or PCAPNG** file.

```bash
tshark -r demo.pcapng
```

> You can combine it with `-c` to **limit** how many packets to show:

```bash
tshark -r demo.pcapng -c 10
```

## 💾 Write Data to File

You can **export packets** to a new PCAP file using `-w`:

```bash
tshark -i eth0 -w sample-capture.pcap
```

### 🔎 Why use this?

- Save **suspicious traffic** for further review
- Share **only relevant packets** with your team
- Build a library of **attack samples**

## 🧮 Show Packet Bytes

Use `-x` to view each packet’s **hexadecimal and ASCII** dump:

```bash
tshark -r demo.pcapng -c 1 -x
```

- ⚠️ This will produce **verbose output** for each packet — use with caution and combine with `-c` to avoid flooding the terminal.

## 🗂 Verbose Output

By default, TShark shows **only one line per packet**. Use `-V` to display **detailed fields**, similar to Wireshark’s middle pane.

```bash
tshark -r demo.pcapng -c 1 -V
```

### 🔧 When to Use

- For **deep analysis** of a single/small group of packets
- When scripting or extracting specific fields
- During forensic review of suspicious behavior
    
- 🧠 **Tip:** Combine `-V` with filters to isolate relevant packets and reduce noise.

## 🧵 Quiet Mode

Use `-q` if you want to run TShark **without terminal output**. Useful when you're only writing to file with `-w`.

```bash
tshark -r demo.pcapng -q -w out.pcap
```

---

# 🎯 Capture Condition Parameters – TShark

TShark allows analysts to **control how and when to stop capturing** packets using specific conditions. These can be configured for **single runs** or **looped captures**, helping you manage storage and automate traffic collection.

## ⚙️ Autostop Parameters (`-a`)

Define **capture conditions** for a **single run**. The capture will **automatically stop** once the condition is met.

| **Parameter** | **Purpose** | **Example** |
|---------------|-------------|-------------|
| `duration:X` | Stop after **X seconds**. | `tshark -w test.pcap -a duration:1` |
| `filesize:X` | Stop after file reaches **X KB**. | `tshark -w test.pcap -a filesize:10` |
| `files:X` | Stop after generating **X files**. | `tshark -w test.pcap -a filesize:10 -a files:3` |

## 🔁 Ring Buffer Control (`-b`)

Define conditions for **multiple runs in a loop**. Unlike `-a`, these run in a **continuous loop** and recycle files.

| **Parameter** | **Purpose** | **Example** |
|---------------|-------------|-------------|
| `duration:X` | Capture for X seconds, then start new file. | `tshark -w test.pcap -b duration:1` |
| `filesize:X` | Start new file once it reaches X KB. | `tshark -w test.pcap -b filesize:10` |
| `files:X` | Only store up to X files, then **overwrite oldest**. | `tshark -w test.pcap -b filesize:10 -b files:3` |

> 💡 **Note**: These settings **only work during live capture.** If you try using them while reading from a `.pcap`, TShark will throw an error.

.-

## 🧠 Tips and Hints

- You **can combine `-a` and `-b`** for customized behavior.
    ```bash
    tshark -i eth0 -w logs.pcap -b filesize:1000 -b files:5 -a duration:300
    ```
    This will:
    - Capture for 300 seconds total (`-a duration:300`)
    - Create a new file every 1000 KB (`-b filesize:1000`)
    - Maintain only 5 files at a time (`-b files:5`)

- **Use `-a` to ensure the loop stops**. If you use only `-b`, the loop may run infinitely!

## ✅ Summary

| **Mode** | **Flag** | **Purpose** | **Behavior** |
|----------|----------|-------------|--------------|
| Single Run | `-a` | Autostop | Stop after time, size, or file count |
| Looping Run | `-b` | Ring buffer | Continuous capturing with file rotation |

> 🚨 **Use ring buffer mode with caution**, especially on production systems. Always ensure you’re not flooding disk space or missing logs due to overwriting!

---
# 🧰 Packet Filtering Parameters | Capture & Display Filters

TShark supports **two layers** of packet filtering:

1. **Capture Filters** – applied **before** capturing traffic
2. **Display Filters** – applied **after** capturing traffic

Both serve different purposes, and knowing when to use each is crucial for efficient packet analysis.

## 🎯 Filtering Dimensions

| **Type**          | **When Used**         | **Purpose**                                                   | **Changeable** |
|-------------------|------------------------|----------------------------------------------------------------|----------------|
| **Capture Filter** | Before or during capture | Save **only specific traffic** to the capture file (Live filtering) | ❌ No          |
| **Display Filter** | After capture           | **Narrow down visible packets** in a file for analysis         | ✅ Yes         |

- ⚠️ Capture filters are **BPF-based** (Berkeley Packet Filter), whereas display filters use **Wireshark’s filtering syntax**.

## 🛠 Parameters

| **Parameter** | **Purpose** | **Syntax Example** |
|---------------|-------------|---------------------|
| `-f` | **Capture filter** (BPF syntax) | `tshark -f "tcp port 80"` |
| `-Y` | **Display filter** (Wireshark syntax) | `tshark -r file.pcap -Y "http.request"` |

## 🔍 Capture Filter (BPF Syntax)

Used to **limit what’s written to the pcap** file. Efficient for large captures or scope-limited investigations.

### 🔹 Examples:
```bash
tshark -i eth0 -f "port 80"
tshark -i eth0 -f "tcp and host 192.168.1.5"
tshark -f "udp" -w dns-traffic.pcap
```

## 🔎 Display Filter (Wireshark Syntax)

Used for **analyzing already captured traffic**, especially to filter based on fields like HTTP requests, IP addresses, payload content, etc.

### 🔹 Examples:

```bash
tshark -r capture.pcap -Y "http.request" tshark -r demo.pcap -Y "ip.addr == 192.168.1.100" tshark -r traffic.pcap -Y "dns.qry.name contains 'google'"
```

## 🧠 Tips

- **Capture filters** help keep files **small** and **focused**.
- **Display filters** allow **deep packet inspection** post-capture.
- For best practice: combine both!
	```bash
		tshark -i eth0 -f "tcp port 443" -w https-capture.pcap tshark -r https-
		capture.pcap -Y "tls.handshake.type == 1"
	```

>🛡️ Use **capture filters** in high-traffic environments to **prevent performance bottlenecks** and disk flooding.

---
# 🧲 Capture Filters in TShark (BPF Syntax)

TShark uses **Berkeley Packet Filter (BPF)** syntax (same as Wireshark’s capture filters) to define **what packets to capture during a live sniff**. These filters are set **before** the capture begins and help in keeping the capture focused and small.

## 🔹 Basic Syntax

You can combine filters using **Boolean operators** like `and`, `or`, and `not`.

```bash
tshark -f "<filter_expression>"
```


## 🎛️ Filter Components

### 📌 **1. Type (Target Match Type)**

| **Qualifier** | **Description**                                    |
| ------------- | -------------------------------------------------- |
| `host`        | IP address or hostname (default if none specified) |
| `net`         | IP network (CIDR)                                  |
| `port`        | Single port                                        |
| `portrange`   | Range of ports                                     |
#### ✨ Examples:

```bash
tshark -f "host 10.10.10.10" tshark -f "net 10.10.10.0/24" tshark -f "port 80" tshark -f "portrange 80-100"
```

### 📌 **2. Direction (Packet Flow)**

|**Qualifier**|**Description**|
|---|---|
|`src`|Source address|
|`dst`|Destination address|

#### ✨ Examples:

```bash
tshark -f "src host 10.10.10.10" tshark -f "dst port 443"
```

- 🧠 If no direction is specified, it defaults to **either direction**.

### 📌 **3. Protocols**

Filter by specific protocols or MAC addresses.
#### Common protocols:

- `arp`, `ether`, `icmp`, `ip`, `ip6`, `tcp`, `udp`

#### ✨ Examples:

```bash
tshark -f "tcp" tshark -f "udp" tshark -f "ether host F8:DB:C5:A2:5D:81" tshark -f "ip proto 1"  # ICMP (protocol number 1)
```

## 🧪 Practice Scenarios with Command Examples

> Use the `terminator` terminal to run multiple views and simulate traffic.

### 🧍 Host Filtering

- **Noise Command (Terminal-2):**
	- `curl tryhackme.com`

    
- **TShark (Terminal-1):**
    - `tshark -f "host tryhackme.com"`
    

### 🌐 IP Filtering

- **Noise Command:**
    - `nc 10.10.10.10 4444 -vw 5`
    
- **TShark Command:**
    - `tshark -f "host 10.10.10.10"`
    

### 🔢 Port Filtering

- **Noise Command:**
    - `nc 10.10.10.10 4444 -vw 5`
    
    
- **TShark Command:**
    - `tshark -f "port 4444"`
    
### 📡 Protocol Filtering

- **Noise Command (UDP traffic):**
    - `nc -u 10.10.10.10 4444 -vw 5`
    
- **TShark Command:**
	- `tshark -f "udp"`

---
# 🔍 TShark Display Filters

TShark supports **Wireshark’s Display Filter** syntax to filter packets **after** capture, useful for investigating large `.pcap` files or refining live output. Display filters provide **deep protocol-level filtering** (much more granular than capture filters).

## 🧠 Syntax Overview

```bash
tshark -r <file> -Y '<display_filter>'
```

Or during live capture:

```bash
tshark -i <interface> -Y '<display_filter>'
```

Display filters support **Boolean logic**: `and`, `or`, `not`.

## 🔍 Display Filter Categories & Examples

### 🌐 IP Filters

| **Purpose**            | **Command**                            |
| ---------------------- | -------------------------------------- |
| Match any IP (src/dst) | `tshark -Y 'ip.addr == 10.10.10.10'`   |
| Match IP range (CIDR)  | `tshark -Y 'ip.addr == 10.10.10.0/24'` |
| Match source IP        | `tshark -Y 'ip.src == 10.10.10.10'`    |
| Match destination IP   | `tshark -Y 'ip.dst == 10.10.10.10'`    |

### 📦 TCP Filters

| **Purpose**             | **Command**                     |
| ----------------------- | ------------------------------- |
| Any packet with port 80 | `tshark -Y 'tcp.port == 80'`    |
| TCP from source port 80 | `tshark -Y 'tcp.srcport == 80'` |

### 🌐 HTTP Filters

|**Purpose**|**Command**|
|---|---|
|All HTTP packets|`tshark -Y 'http'`|
|HTTP packets with 200 OK status|`tshark -Y 'http.response.code == 200'`|


### 🌐 DNS Filters

|**Purpose**|**Command**|
|---|---|
|All DNS packets|`tshark -Y 'dns'`|
|Only DNS "A" record queries|`tshark -Y 'dns.qry.type == 1'`|


## 🧪 Notes

- You can use these filters with **`-r`** to analyze `.pcap` files or with **`-i`** for live traffic.
- These filters are **read-only** and **non-destructive**—ideal for analysis.
- For live capture + filter:

```bash
tshark -i eth0 -Y 'http.response.code == 200'
```

# 🧠 Story: The Curious Analyst and the Mysterious Packet

Riya, a junior SOC analyst, had just wrapped up her coffee when a critical alert pinged on her dashboard—unusual traffic had been detected on one of the web servers. Her senior was out for lunch, and the rest of the team was swamped. This was her moment.

She didn’t have Wireshark’s GUI installed on the jump box she was working on, so she turned to her secret weapon: **TShark**.
## 🎯 Starting Simple – Using the Command Line

Riya remembered the first step: **Get the lay of the land**.
She listed the available interfaces and selected `eth0` to sniff traffic:

```bash
tshark -D
```

She just wanted to see a sample—50 packets were enough to begin.
```bash
sudo tshark -i eth0 -c 50
```

## 📦 Packet Reading & Writing

While scanning, she noticed some strange destination IPs. She decided to capture a full 5-minute segment of traffic for deeper analysis later:
```bash
tshark -i eth0 -a duration:300 -w suspicious.pcap
```


Curious about what was in there, she opened the file using:
```bash
tshark -i eth0 -a duration:300 -w suspicious.pcap
```

This gave her the **deep packet breakdown** she needed—like Wireshark’s detailed view pane—straight in the terminal.

## 🔁 Autostop & Ring Buffer Ninja Tricks

Just to be safe, Riya set up a **looped capture** with size limits and file rotation for continuous monitoring:
```bash
tshark -i eth0 -w live.pcap -b filesize:5000 -b files:4 -a duration:900
```
This way, she could **monitor continuously** but **never blow up disk space**—a trick she picked up from last week’s threat hunting workshop.

## 🔎 Filtering the Noise – Capture Filters

The packet volume was overwhelming. So she decided to **limit the capture** only to HTTP traffic:
```bash
tshark -i eth0 -f "port 80" -w http-traffic.pcap
```
Later, she got more specific:
```bash
tshark -i eth0 -f "src host 192.168.1.5 and tcp" -w suspect.pcap
```

Only capturing **specific traffic** helped her keep file sizes small and relevant.

## 🔬 Display Filters for Forensics

When it was time to analyze captured `.pcap` files, she used **display filters** like a pro:
```bash
tshark -r suspect.pcap -Y "http.request
```

She even dug into **HTTP status codes**:

```
tshark -r suspect.pcap -Y "http.response.code == 200"
```

The packets revealed a repeated connection to a sketchy domain. DNS requests for the domain appeared too frequent, and subdomain names were unusually long:
```bash
tshark -r suspect.pcap -Y "dns.qry.name contains 'weird'
```
Boom. **C2 beaconing** via DNS tunnels—she had seen this before in last month’s threat brief.

## 🧮 CLI Power with Grep & Friends

To wrap up her triage, she combined her tools:

```bash
tshark -r suspicious.pcap | grep "POST" | cut -d " " -f 3 | sort | uniq -c
```

This gave her a **list of HTTP POST destinations** sorted by frequency—a perfect pivot point for blocking those IPs at the firewall.

## 🎉 Victory

By the time her senior returned, Riya had:

- Captured targeted traffic
- Analyzed and filtered packets
- Found the C2 behavior
- Exported key artifacts
- Drafted a mini incident report
    

All of it—**without opening a single GUI**.

Her secret?  
- **Command-line mastery.**  
- **TShark.**  
- **Obsidian notes like yours.**