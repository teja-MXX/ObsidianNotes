# ğŸ“Š Command-Line Wireshark Features I â€“ Statistics with TShark

TShark is the CLI equivalent of Wireshark and supports many of its analysis features â€” including **statistics**, **colorized output**, and **protocol analysis**.

- âœ… These features apply to **all packets** unless a `-Y <display filter>` is specified.

## ğŸ¨ `--color`

Enables **colorized output** similar to Wiresharkâ€™s GUI.

```bash
tshark --color
```

## ğŸ“ˆ `-z` Statistics Option

The `-z` parameter is used to extract **statistical data** from the capture.

### ğŸ“– View All Available Statistics Options:

```bash
tshark -z help
```

This command lists all statistical reporting modules, like protocol hierarchy, flow graphs, endpoints, conversations, etc.

## ğŸ“Œ Sample Usage

### View Protocol Hierarchy Statistics (equivalent to Wireshark's _Statistics > Protocol Hierarchy_):

```bash
tshark -r file.pcap -z io,phs
```

## ğŸ¨ Colourised Output

TShark can provide **colourised outputs** to help analysts:

- Speed up visual packet analysis
- Quickly spot anomalies
- Mimic the familiar **Wireshark-style packet highlighting**

```bash
user@ubuntu$ tshark -r colour.pcap --color
```
![[Pasted image 20250611110217.png]]

## ğŸ“Š TShark Statistics: Protocol Hierarchy

The **Protocol Hierarchy** feature helps analysts quickly understand:

- Protocols observed in the capture
- Total packet count per protocol
- Total byte size per protocol
- A tree-structured breakdown of protocol layers


### ğŸ” Why Use Protocol Hierarchy?

- Gives a **summary overview** of the capture
- Helps identify **dominant protocols**
- Allows analysts to **focus** on suspicious or interesting protocol layers

Use theÂ `-z io,phs -q`Â parameters to view the protocol hierarchy.
![[Pasted image 20250611110616.png]]

After viewing the entire packet tree, you can focus on a specific protocol as shown below. Add theÂ `udp`Â keyword to the filter to focus on theÂ UDPÂ protocol.
![[Pasted image 20250611110656.png]]

## ğŸ“ TShark Statistics: Packet Lengths Tree

The **Packet Lengths Tree** provides a visual breakdown of the **distribution of packet sizes** in a capture. This helps identify:

- Unusually large packets
- Very small packets
- Distribution clusters (e.g., many packets in a certain size range)

### ğŸ” Why Use Packet Length Tree?

- Detect **abnormal traffic patterns**
- Quickly identify **oversized** or **tiny packets**
- Understand **overall packet size distribution**

![[Pasted image 20250611110848.png]]

## ğŸŒ TShark Statistics: Endpoints

The **Endpoints view** provides a list of all **unique communication endpoints** (IP, MAC, TCP, UDP, etc.) involved in a capture, along with:

- Number of packets sent/received
- Number of bytes
- Endpoint address type (IPv4, IPv6, MAC, etc.)

### ğŸ› ï¸ Command Syntax

```bash
tshark -r <file>.pcap -z endpoints,<type> -q
```

For live capture:
```bash
tshark -i <interface> -z endpoints,<type> -q
```

- `-z endpoints,<type>`: Generate statistics for specified endpoint type
- `-q`: Suppress packet details

### ğŸ“˜ Example


```bash
tshark -r capture.pcap -z endpoints,ip -q
```

This will output a table of all **IPv4 endpoints** showing:

- IP address
- Packet count
- Bytes sent/received

### ğŸ§° Supported Filters

|Filter|Description|
|---|---|
|`eth`|Ethernet (MAC) addresses|
|`ip`|IPv4 addresses|
|`ipv6`|IPv6 addresses|
|`tcp`|TCP endpoints (IPv4 & IPv6 supported)|
|`udp`|UDP endpoints (IPv4 & IPv6 supported)|
|`wlan`|IEEE 802.11 (Wi-Fi MAC addresses)|
![[Pasted image 20250611111448.png]]

## ğŸ” TShark Statistics: Conversations

The **Conversations view** shows communication between two endpoints as **pairs**, offering a high-level overview of:

- Traffic **direction**
- **Number of packets** and **bytes** exchanged
- Initiator and responder roles


### ğŸ› ï¸ Command Syntax

```bash
tshark -r <file>.pcap -z conv,<type> -q
```

For live capture:
```bash
tshark -i <interface> -z conv,<type> -q
```

- `-z conv,<type>`: Show conversation statistics by type
- `-q`: Quiet mode (suppress detailed packet output)

### ğŸ“˜ Example
![[Pasted image 20250611112048.png]]

This displays all IP-based two-way conversations with:

- Source IP â†” Destination IP
- Packet count (in both directions)
- Bytes transferred

### ğŸ§° Supported Filters

|Filter|Description|
|---|---|
|`eth`|Ethernet (MAC) conversations|
|`ip`|IPv4 conversations|
|`ipv6`|IPv6 conversations|
|`tcp`|TCP session-level conversations|
|`udp`|UDP conversations|
|`wlan`|IEEE 802.11 (Wi-Fi) conversations|
## ğŸ§  TShark Statistics: Expert Info

The **Expert Info** view in TShark provides **diagnostic messages and protocol anomalies**, similar to Wiresharkâ€™s **Expert Information tab**. It helps analysts identify:

- Protocol violations
- Malformed packets
- Unusual traffic patterns
- Potential errors and warnings

### ğŸ› ï¸ Command Syntax

```bash
tshark -r <file>.pcap -z expert -q

# For live capture:
tshark -i <interface> -z expert -q
```
 
- `-z expert`: Displays expert-level comments/statistics
- `-q`: Suppresses packet-by-packet output, showing only expert data

![[Pasted image 20250611112836.png]]

## ğŸ•µï¸ Story: _The Curious Case of the Lagging Server_

### Scene 1: The Incident

Raj, a junior cybersecurity analyst, received an urgent call from the DevOps team:

> â€œOur main application server is **lagging heavily** and **users are complaining of timeouts**! Can you check if itâ€™s a **network issue**?â€

Raj doesnâ€™t have a GUI. He only has SSH access to the serverâ€”and that's where **TShark** becomes his superhero tool.

### Scene 2: Starting with a Simple Sniff

Raj launches a capture using:

```bash
tshark -i eth0 --color
```

The `--color` flag helps highlight packets like Wireshark does, making it easier to spot anomalies while reading terminal output.

### Scene 3: Let the Stats Begin

To avoid drowning in thousands of lines, Raj decides to use **statistical tools** that TShark offers.

#### ğŸ§± Step 1: Protocol Hierarchy (`-z io,phs -q`)

```bash
tshark -i eth0 -z io,phs -q
```

This command **shows the hierarchy of all protocols** in the capture. He notices:

- **50% is HTTP**
- **25% is DNS**
- **Surprisingly, a lot of ARP traffic**!
    
This tells Raj that a **ton of name resolution** and **network-level chatter** is happening. Somethingâ€™s weird here...

#### ğŸ“¦ Step 2: Packet Length Tree (`-z plen,tree -q`)

He wants to know **what size packets are most common**:

```bash
tshark -i eth0 -z plen,tree -q
```

This reveals a lot of **tiny packets (60-80 bytes)** and **a few very large ones (~1500 bytes)**, hinting at possibly **a flood of small requests**.

#### ğŸŒ Step 3: IP Endpoints (`-z endpoints,ip -q`)

To spot which IPs are **talking the most**, Raj uses:

```bash
tshark -i eth0 -z endpoints,ip -q
```

Boom ğŸ’¥ â€” a **single IP** appears with **10x the number of packets** compared to others. Possibly the culprit.

#### ğŸ” Step 4: Conversations (`-z conv,ip -q`)

To see **which devices are having intense back-and-forth**, he runs:

```bash
tshark -i eth0 -z conv,ip -q
```

This helps him discover a **flood of requests** between the same two IPs (maybe a loop, or abuse).

#### âš ï¸ Step 5: Expert Info (`-z expert -q`)

Finally, he wants to know what TShark thinks about all of this:

```bash
tshark -i eth0 -z expert -q
```

This shows:

- â€œ**Duplicate ACKs**â€
- â€œ**TCP Retransmissions**â€
- â€œ**Malformed DNS queries**â€
    
Thatâ€™s the **smoking gun**. The network is overloaded with **faulty DNS requests** and **TCP issues**.


### ğŸ§© Conclusion: Case Solved

Raj shares the output with the team and confirms:

> â€œLooks like a misconfigured internal script is **spamming the DNS server** and causing **network congestion**.â€

This is how he solved the case

### ğŸ“˜ Recap Summary of TShark Features Raj Used

|Feature|Command|Why Raj Used It|
|---|---|---|
|**Color output**|`--color`|Makes real-time sniffing more readable|
|**Protocol hierarchy**|`-z io,phs -q`|Understand which protocols dominate|
|**Packet length tree**|`-z plen,tree -q`|Spot abnormal packet sizes|
|**Endpoints view**|`-z endpoints,ip -q`|Find IPs sending/receiving most traffic|
|**Conversations view**|`-z conv,ip -q`|Discover whoâ€™s talking to whom and how much|
|**Expert info**|`-z expert -q`|Automatically catch anomalies|
### ğŸ§  Tip

After reading your notes, re-read this story and **imagine yourself as Raj** using TShark step-by-step in a crisis. Itâ€™ll help reinforce each flag and why itâ€™s used, so youâ€™ll not only _know_ the commandsâ€”youâ€™ll understand _when and why_ to use them.

Let me know if you want a similar story for `capture filters`, `display filters`, or `-a` & `-b` conditions!

---

# ğŸ“Š Command-Line Wireshark Features II | Specific Filters for Particular Protocols


## ğŸ” General Overview

TShark offers protocol-specific statistics filters that mirror some GUI features of Wireshark. These help analysts focus investigations on particular protocols and gain summarized insights into packet behavior.

## ğŸ“ˆ Statistics: IPv4 and IPv6

### ğŸ”¸ Protocol Type Distribution

Shows packet statistics for each protocol:

```bash
tshark -z ptype,tree -q
```

![[Pasted image 20250611184726.png]]

### ğŸ”¸ IP Hosts Summary

Gives a summary of all unique IP addresses seen in the capture:

- **IPv4**:
```bash
tshark -z ip_hosts,tree -q
```

- **IPv6**:
```bash
tshark -z ipv6_hosts,tree -q
```

![[Pasted image 20250611184750.png]]
### ğŸ”¸ Source & Destination IP Stats

Correlates IPv4/IPv6 packets based on source and destination addresses:
- **IPv4**
```bash
tshark -z ip_srcdst,tree -q
```

- **IPv6**:
```bash
tshark -z ipv6_srcdst,tree -q
```

![[Pasted image 20250611184823.png]]
### ğŸ”¸ Destination Services & Ports

Focuses on **outgoing traffic**â€”helpful to detect services in use and potentially malicious exfiltration:

- **IPv4**:
```bash
tshark -z dests,tree -q
```

- **IPv6**:
```bash
tshark -z ipv6_dests,tree -q
```

![[Pasted image 20250611184932.png]]

## ğŸŒ Statistics: DNS

Summarizes DNS traffic, including requests and response patterns.
```bash
tshark -z dns,tree -q
```

Use this to detect:

- DNS tunneling
- Suspicious frequency of DNS queries
- Query types and distributions
    
![[Pasted image 20250611184949.png]]
## ğŸŒ Statistics: HTTP

Provides granular breakdown of HTTP activity, requests, and responses:

|Purpose|Command|
|---|---|
|HTTP packet and status summary|`tshark -z http,tree -q`|
|HTTP/2 packet and status summary|`tshark -z http2,tree -q`|
|HTTP server load distribution|`tshark -z http_srv,tree -q`|
|HTTP request summary|`tshark -z http_req,tree -q`|
|HTTP requests/responses in sequence|`tshark -z http_seq,tree -q`|

Use these to detect:

- Phishing pages
- Beaconing activity
- C2 traffic over HTTP
- Unusual load on specific paths or services

![[Pasted image 20250611185013.png]]
## ğŸ•µï¸â€â™€ï¸ Story: "The Curious Case of the Leaky Web Server"

### ğŸ§© Setup

Late one Tuesday evening, Mayaâ€”an intermediate SOC analystâ€”received an alert from the SIEM. One of the internal servers was making frequent outbound DNS and HTTP requests. Nothing in the logs screamed malware, but something felt off.

Her GUI tools were down for scheduled maintenance, so she pulled up her terminal and whispered her favorite words:

> â€œTime for TShark.â€

And she opened TShark

### ğŸ“¦ Step 1: Overviewing Protocol Usage

She started by checking what types of traffic dominated the capture:
```bash
tshark -r suspect.pcap -z ptype,tree -q
```

â†’ Boom. HTTP and DNS were off the charts.

### ğŸ§  Step 2: Identify All IP Addresses

Letâ€™s see all the unique hosts involved:
```bash
tshark -r suspect.pcap -z ip_hosts,tree -q
```
â†’ She saw an unfamiliar public IP repeated across hundreds of connections.

### ğŸ¯ Step 3: Whoâ€™s Talking to Whom?

Time to correlate the sender and receiver IPs:
```bash
tshark -r suspect.pcap -z ip_srcdst,tree -q
```

â†’ It confirmed the internal server was pushing requests to an unknown domain hosted on a sketchy IP. Maya raised an eyebrow.

### ğŸŒ Step 4: Zooming In On DNS

Curious about the DNS pattern, she ran:
```bash
tshark -r suspect.pcap -z dns,tree -q
```

â†’ Dozens of DNS queries, all slightly different, with **very long subdomains**. Classic DNS tunneling behavior.

### ğŸŒ Step 5: HTTP Patterns & C2 Beaconing

Next, she dove into the HTTP packet summary:
```bash
tshark -r suspect.pcap -z http,tree -q
```

â†’ A flood of HTTP GET requests with strange URIs.

She checked if it was a timed beacon:

```bash
tshark -r suspect.pcap -z http_seq,tree -q
```

â†’ The responses followed a **consistent time gap**. This was **definitely beaconing**.



### ğŸ“‰ Step 6: Load and Requests Review

To verify if any endpoint was overloaded or acting like a drop site:
```bash
tshark -r suspect.pcap -z http_srv,tree -q
```

â†’ One specific URI path was receiving 90% of traffic.

She pulled a summary of all requests:
```bash
tshark -r suspect.pcap -z http_req,tree -q
```

â†’ Repeated requests using a suspicious User-Agent: `Mozilla/5.0 (BackdoorBot)`.

### ğŸ§© Step 7: Destination Recon

Now that she had the external IP, she wanted to see how many destinations the server contacted:
```bash
tshark -r suspect.pcap -z dests,tree -q
```

â†’ All activity was funneled toward one IP. Another red flag.

### ğŸ“Œ Conclusion

Within 30 minutes, Maya had:

- Identified the internal source host
- Confirmed DNS tunneling
- Spotted HTTP beaconing
- Mapped suspicious traffic to a single external IP
    
She submitted an incident report, added the indicators to the firewall blocklist, and updated the detection rules.

Her manager pinged her:
> â€œGUI was down, but you still nailed it? Thatâ€™s TShark-fu at its best.â€

---


# ğŸ§ª Command-Line Wireshark Features III | Streams, Objects, and Credentials

TShark supports additional advanced CLI operations, such as following streams, exporting objects, and extracting cleartext credentials from network traffic.

## ğŸ” Follow Stream

TShark can follow TCP, UDP, HTTP, and HTTP2 streamsâ€”similar to Wiresharkâ€™s â€œFollow Streamâ€ feature.

**Syntax Structure**:
```bash
tshark -r demo.pcapng -z follow,<protocol>,<view_mode>,<stream_number> -q
```

### Supported Protocols:
- `tcp`
- `udp`
- `http`
- `http2`
### View Modes:
- `ascii`
- `hex`
### Examples:
Follow TCP stream 0 in ASCII:
```bash
tshark -r file.pcap -z follow,tcp,ascii,0 -q
```

Follow UDP stream 1 in HEX:
```bash
tshark -r file.pcap -z follow,udp,hex,1 -q
```

![[Pasted image 20250611190105.png]]
## ğŸ“¦ Export Objects

TShark can export files transferred over various protocols such as HTTP, SMB, TFTP, IMF, and DICOM.

**Syntax Structure**:
```bash
tshark -r demo.pcapng --export-objects <protocol>,<destination_folder> -q
```
### Supported Protocols:
- `http`
- `smb`
- `tftp`
- `dicom`
- `imf`
### Example:
Export HTTP objects:
```bash
tshark -r file.pcap --export-objects http,/home/user/extracted -q
```

![[Pasted image 20250611190141.png]]
## ğŸ” Extracting Credentials

TShark can extract **cleartext credentials** from protocols like:

- FTP
- HTTP
- IMAP
- POP
- SMTP

**Command**:
```bash
tshark -r file.pcap -z credentials -q
```

> Note: This will show any detected cleartext usernames/passwords in supported protocols.

The rest all will not be supported

![[Pasted image 20250611190208.png]]
## ğŸ“ Summary

| Feature           | Command Example                                                                 |
|------------------|----------------------------------------------------------------------------------|
| Follow TCP Stream | `-z follow,tcp,ascii,0 -q`                                                       |
| Export HTTP Files | `--export-objects http,/path/to/save -q`                                        |
| Extract Credentials | `-z credentials -q`                                                           |

## ğŸ•µï¸ Story: The Mystery of the Leaked Credentials

It was a quiet afternoon in the SOC (Security Operations Center) when Anika received an alert. One of the HR endpoints had initiated a connection to an unknown domain overnight. The domain was flagged in a threat feed as being used for phishing and malware campaigns. She had a `.pcap` file from the firewall logs ready to inspect.

Since she was working over SSH and didnâ€™t have GUI access to Wireshark, Anika turned to TShark.


### ğŸ” Step 1: Following the HTTP Stream

She suspected data exfiltration or malware download. To investigate further, Anika needed to follow the HTTP traffic to reconstruct the conversation.

She ran:
```bash
tshark -r suspect.pcap -z follow,http,ascii,0 -q
```
- Boom. The response included a suspicious `exe` file hosted on the server.

### ğŸ“¦ Step 2: Exporting Objects
To inspect the file itself, Anika extracted all HTTP objects from the pcap using:

```bash
tshark -r suspect.pcap --export-objects http,/home/anika/extracted -q
```

She quickly located the `.exe` file in the extracted folder â€” the filename was disguised as an invoice, but the hash matched a known malware sample on VirusTotal.

### ğŸ” Step 3: Checking for Leaked Credentials

Just to be thorough, Anika checked if any cleartext credentials were exposed. She knew that TShark could parse common protocols like FTP, IMAP, and SMTP.

```bash
tshark -r suspect.pcap -z credentials -q
```

Sure enough, she spotted a leaked username and password exchanged in cleartext over HTTP Basic Auth. It was one of the internal HR users â€” likely the one who triggered the initial infection.

### ğŸ§© Case Solved

Thanks to her command-line skills with TShark:

- She reconstructed the HTTP stream to identify the suspicious file.
- Exported it for malware analysis.
- Detected compromised credentials being sent in plain text.
    
The SOC took action immediately:

- Reset the credentials.
- Reimaged the affected endpoint.
- Blocked the malicious domain across all firewalls.
    
Anika logged her findings and walked to the break room for a well-deserved cup of coffee. Another incident contained â€” all through the power of TShark.

---

# ğŸ§ª Advanced Filtering Options in TShark â€“ `contains`, `matches`, and Field Extraction


In-depth packet analysis often requires advanced filtering that goes beyond basic field matching. TShark supports powerful filter operators: `contains`, `matches`, and also lets analysts **extract specific fields** from packets for precision analysis.

## ğŸ” `contains` Filter
- **Type**: Comparison operator
- **Description**: Searches for a **specific string** (case-sensitive) inside packet fields.
- **Usage**: Similar to Wiresharkâ€™s **Find** feature.
- **Limitation**: Only works on **string fields**, not integers.

### ğŸ§ª Example:
Find all HTTP packets where the `server` field contains the word `Apache`.

```bash
http.server contains "Apache"
```

## ğŸ” `matches` Filter

- **Type**: Comparison operator
- **Description**: Uses **regular expressions** to match patterns in string fields.
- **Case-insensitive**.
- **Limitation**: Cannot be used with integer fields. Complex regex queries may have a margin of error.
    
### ğŸ§ª Example:

Find all HTTP packets using the methods `GET` or `POST`.

```bash
http.request.method matches "(GET|POST)"
```


## ğŸ§¬ Field Extraction with `-T fields`

TShark allows you to **extract specific fields** and format them for custom outputs.

### ğŸ“˜ Syntax:

```bash
tshark -r file.pcap -T fields -e <field1> -e <field2> -E header=y
```

- `-T fields`: Tells TShark to output only selected fields.
- `-e`: Specify fields to extract (repeat for multiple).
- `-E header=y`: Adds column headers for readability.
    
### ğŸ§ª Example:

Extract source and destination IP addresses:

```bash
tshark -r capture.pcap -T fields -e ip.src -e ip.dst -E header=y
```

This outputs a table of IP addresses from the packet capture.
![[Pasted image 20250611192732.png]]

## ğŸ’¡ Tips

- `contains` is great for quick value searches (case-sensitive).
- `matches` allows complex, regex-based pattern matching (case-insensitive).
- Always prefer **HEX or regex** over plain ASCII for precision in complex filtering.
- These filters cannot be used on fields with numeric values.

![[Pasted image 20250611192806.png]]

![[Pasted image 20250611192833.png]]

## âœ… Use Cases

|Task|Filter|
|---|---|
|Find all responses from Apache servers|`http.server contains "Apache"`|
|List all GET or POST HTTP requests|`http.request.method matches "(GET|
|Extract IP pairings from a PCAP|`-T fields -e ip.src -e ip.dst -E header=y`|

## ğŸ•µï¸â€â™‚ï¸ Story: The Hunt for the Phantom Packet â€“ Advanced TShark Filtering in Action

### ğŸ¬ Scene 1: A Suspicious Traffic Spike

It was late in the night, and Analyst Aisha leaned over her keyboard, squinting at a sudden spike in HTTP traffic on one of the internal servers. The IDS had remained quiet â€” no obvious signatures triggered â€” but something felt off.

>"I need to dig deeper," Aisha muttered. She fired up **TShark**. Time to hunt.

And she opened TShark

### ğŸ” Scene 2: The Apache Ghost

She recalled that most of the web servers in the company used NGINX. But if an attacker was hiding in plain sight using a rogue Apache server?

> â€œWhat if there's a hidden Apache server broadcasting its presence?â€

She ran:
```bash
tshark -Y 'http.server contains "Apache"'
```

Boom. One packet stood out. It wasn't just unusual â€” it was an internal IP hosting a rogue web server.

### ğŸ§  Scene 3: Pattern Recognition

Feeling the adrenaline, Aisha asked herself: 
>_Could they be serving malicious PHP or HTML payloads?_

Instead of filtering one by one, she unleashed **regex power**:

```bash
tshark -Y 'http.request.method matches "(GET|POST)"'
```

Suddenly, a wave of traffic emerged â€” requests serving `.php` files from an endpoint that wasnâ€™t even registered in DNS.

_â€œThis is it,â€_ she thought. _â€œA webshell delivery point.â€_

### ğŸ“‹ Scene 4: Extracting the Breadcrumbs

Aisha knew that mapping the communication flow would be key for the report.

She didnâ€™t need full packet dumps â€” just the **source and destination IPs** to start mapping the attackerâ€™s reach:

```bash
tshark -r capture.pcap -T fields -e ip.src -e ip.dst -E header=y
```

This gave her a clean, readable list of who talked to whom â€” no distractions. It was like watching the attacker draw lines across the internal map.

### ğŸ§  Scene 5: Pro-Level Probing

"Not every evil packet is obvious,"  she reminded herself. 
>"Sometimes they hide in the plain text, but their behavior tells the story."

She made a mental note: _next time, use HEX-based search and `matches` more often â€” those regex filters are gold._
And with that, she wrote her report, flagged the suspicious IPs, and prepped the threat-hunting team for follow-up.

### âœ… Takeaways from Aisha's Investigation

- ğŸ§ª **Use `contains`** to look for specific case-sensitive strings (great for known headers or server banners).
- ğŸ” **Use `matches`** to hunt with regex â€” ideal for identifying suspicious HTTP methods or patterns.
- ğŸ“¤ **Extract specific fields** with `-T fields -e fieldname` to keep your output clean and automation-friendly.
    
By mastering these advanced filters, Aisha had peeled back the layers of obfuscation and caught the attacker red-handed.

---

# ğŸ› ï¸ Use Cases: Extracting Key Info with TShark

When investigating a case, a security analyst must efficiently extract critical data like **hostnames**, **DNS queries**, and **user-agents** from packet captures. These elements are often considered **low-hanging fruits** in early-stage threat hunting and forensics.

This section demonstrates one of the most common and useful use cases for any analyst using TShark and Linux command-line tools.

## ğŸ–¥ï¸ Use Case: Extract Hostnames from DHCP Packets

### âœ… Goal
Identify and extract **hostnames** from DHCP packets in a `.pcapng` file using `TShark` and clean the output for analysis.

## ğŸ§ª Raw TShark Command
```bash
tshark -r hostnames.pcapng -T fields -e dhcp.option.hostname
```
This command extracts **DHCP hostnames** from the specified `.pcapng` file.

## ğŸ“¦ Output Management Using Linux CLI Tools

Raw output may contain **duplicates**, **empty lines**, or be in a **random order**. We clean it using the following pipeline:
```bash
tshark -r hostnames.pcapng -T fields -e dhcp.option.hostname | awk NF | sort -r | uniq -c | sort -r
```

### ğŸ§  Explanation of Each Step

|**Command Segment**|**Purpose**|
|---|---|
|`tshark -r ...`|Extract hostname field from DHCP packets|
|`awk NF`|Remove empty lines from output|
|`sort -r`|Sort the list in reverse alphabetical order|
|`uniq -c`|Count and list unique occurrences|
|`sort -r`|Sort final output from most to least frequent|
## ğŸ§  Why This Matters

- Quickly reveals **most common hosts** seen in the traffic.
- Great starting point for **inventory validation**, **anomaly detection**, or **compromise scope assessment**.
- Useful in environments where DHCP hostnames follow naming conventions (e.g., `HR-PC-01`, `WIN10-AD`, etc.).
    
## ğŸ§¬  ExtractÂ DNSÂ Queries
![[Pasted image 20250611194335.png]]

## ğŸ§¬  Extract User Agents
![[Pasted image 20250611194403.png]]

## ğŸ§µ **Story: The Curious Analyst and the Noisy Network**

It was a regular Tuesday morning at ACME Corp, and junior analyst Mira sipped her filter coffee while reviewing the overnight alerts. One alert stood out â€” a sudden surge in DHCP traffic just after midnight. Intrigued, she opened her terminal and loaded up the `.pcapng` file from the network sensor.

>"Letâ€™s start with the basics," she thought.

She remembered that when DHCP packets are involved, one of the first things to check is **hostnames** â€” often the quickest way to profile devices on the network.

So, she fired up TShark:
```bash
tshark -r hostnames.pcapng -T fields -e dhcp.option.hostname
```

Boom. A long list of hostnames spilled onto her screen. But wait â€” there were **duplicates**, **empty lines**, and **random noise**. Scanning through manually wasnâ€™t going to cut it.

Mira recalled her mentor's advice:

> â€œUse the shell like a scalpel. Donâ€™t just extract data â€” **refine it**.â€

She piped the output through her Swiss army of shell commands:

```bash
tshark -r hostnames.pcapng -T fields -e dhcp.option.hostname | awk NF | sort -r | uniq -c | sort -r
```

This tiny one-liner turned a chaotic mess into a **clean, sorted list** of hostnames with the number of times each appeared.

There it was â€” **"W1NXPLOIT-99"**, a hostname that didn't match ACME's naming convention and showed up over 40 times. Suspicious.

Mira raised an eyebrow and tagged the asset for deeper inspection.  
It turned out to be a rogue device using DHCP to blend into the environment. Thanks to a simple, elegant TShark + shell combo, Mira was already one step ahead.

That morning, Mira didnâ€™t just catch an anomaly â€” she sharpened her own analytical instincts.

Still riding the high from catching the rogue device, Mira knew she couldnâ€™t stop at hostnames.

>"If someone planted a suspicious system on our network," she thought, **"it's likely doing name lookups or beaconing out."**

Her next move?
-  **Extract DNS Queries** to see what domains were being contacted.

### ğŸ§ª DNS Analysis

She ran the following command to pull out DNS query names:

```bash
tshark -r suspicious-dns.pcapng -T fields -e dns.qry.name
```
A flood of results appeared â€” from normal requests like `update.microsoft.com` to weird ones like:
- `ajskd2132d.maliciousdomain.co` 
- `ocean-latte.store`
- `dnslog.trickster.com`

But again, **duplicates and noise** were getting in the way. She refined the results like a pro:

```bash
tshark -r suspicious-dns.pcapng -T fields -e dns.qry.name | awk NF | sort | uniq -c | sort -nr
```

At the top of the list were repeated queries to `ajskd2132d.maliciousdomain.co`.

Miraâ€™s intuition buzzed.

That _wasnâ€™t_ a normal domain.  
A reverse DNS lookup and a quick VirusTotal scan confirmed: **C2 beaconing domain**.

### ğŸ§ª User-Agent Analysis

She wasn't done yet. Time to investigate **HTTP headers**, especially the **User-Agent** strings, to see if anything unusual stood out.

She used:
```bash
tshark -r http-traffic.pcapng -T fields -e http.user_agent
```

And among the typical browser strings like:
- `Mozilla/5.0 (Windows NT 10.0; Win64; x64)...`

She spotted something off:

- `curl/7.68.0 python-requests/2.25.1 powershell/1.0`

That last one? Definitely shady.
Normal users donâ€™t send HTTP requests from **PowerShell** or **Python scripts** unless something automated (or malicious) is going on.

Again, Mira piped the output for clarity:

```
tshark -r http-traffic.pcapng -T fields -e http.user_agent | awk NF | sort | uniq -c | sort -nr
```

That **PowerShell user-agent**?  
Repeated 18 times in a span of 3 minutes.

## ğŸ¯ The Final Picture

Mira now had:

- A suspicious hostname.
- DNS queries pointing to a known malicious domain.
- An abnormal user-agent doing repeated HTTP POSTs.
    
She pivoted to endpoint logs, correlated everything, and confirmed: a **PowerShell-based C2 agent** was running silently on one of the internal systems.

Thanks to **TShark**, a few shell pipes, and her growing curiosity, Mira pieced together a real intrusion â€” and shut it down before it could exfiltrate any data.


### Moral of the Story:  
With command-line tools and sharp pattern recognition, you can paint an entire breach timeline â€” one field at a time.

Would you like the next part to cover **Exporting Objects**, **Following Streams**, or **Credential Extraction** using TShark?