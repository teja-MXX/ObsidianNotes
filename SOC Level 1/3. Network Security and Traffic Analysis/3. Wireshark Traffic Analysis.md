## ðŸ§¾ Identifying Hosts in Network Investigations

### ðŸŽ¯ Why Host Identification Matters

- Helps determine **where to start an investigation**.
- Allows mapping of **malicious activity** to specific users or hosts.
- Aids in building a **network inventory** during incident response.
    
### ðŸ–¥ï¸ Host and User Naming Patterns

- **Enterprise networks** often use **structured naming conventions** for:
    - Usernames (e.g., `john.doe`, `jdoe01`)
    - Hostnames (e.g., `HR-LAPTOP-01`, `SRV-DC01`)
        
#### âœ… Pros:
- Easy recognition of device roles or user ownership.
- Simplifies asset management and tracking.

#### âŒ Cons:
- Predictable naming conventions can be **exploited by attackers** to blend in or impersonate assets.
    
### ðŸ§ª Protocols Useful for Host & User Identification

|Protocol|Use|
|---|---|
|**DHCP**|Maps IP addresses to MAC addresses and sometimes hostnames.|
|**NBNS (NetBIOS)**|Reveals hostname and user information during name resolution.|
|**Kerberos**|Shows authentication traffic with usernames and service access patterns.|

### ðŸ“– Story Summary: Finding the Infected Host

Imagine you're a SOC analyst named **Ravi**, and your SIEM just flagged **suspicious DNS traffic** from an internal IP: `192.168.10.45`.

To trace it:

1. You check **DHCP logs** and discover:
    - IP `192.168.10.45` is assigned to MAC `00:1A:2B:3C:4D:5E`
    - Hostname: `FINANCE-PC02`    
2. You sniff **NBNS traffic** and confirm the hostname `FINANCE-PC02` sends out name queries, confirming the machineâ€™s identity.
3. Looking at **Kerberos logs**, you observe that user `nisha.k` has authenticated from this host recently.
    
Now you know:
- The suspicious activity is tied to **user Nisha** on **FINANCE-PC02**.
- You can check her login patterns, investigate her recent activity, and isolate the machine for forensic analysis.
    
Because you used DHCP, NBNS, and Kerberos logs, youâ€™ve confidently **mapped an IP to a host and user**, giving you a strong lead to start remediation.

---
# ðŸ›¡ï¸ Tunnelling Traffic: ICMP and DNS

## What is Tunnelling?

Tunnelling (aka **port forwarding**) is a technique to securely transfer data/resources across different network segments or zones. It is used in both directions:

- From **internet to private networks**
- From **private networks to internet**

### Key Features:
- Data is **encapsulated** to make traffic appear normal.
- Ensures **anonymity** and **traffic security**.
- Commonly used in enterprise networks.
- Also exploited by **adversaries** to bypass firewalls using trusted protocols like **ICMP** and **DNS**.

## ðŸ“¡ ICMP Analysis

**ICMP (Internet Control Message Protocol)** is designed for **diagnostics** and **error reporting** at the network layer.

### Legitimate Uses:
- Ping/Traceroute
- Path MTU Discovery
- Network error messages

### Malicious Use:
- **Denial-of-Service (DoS)** attacks
- **Data exfiltration**
- **Command & Control (C2)** channels

### ICMP Tunnelling in a Nutshell:
- Often starts **after malware execution** or **vulnerability exploitation**.
- Uses the **ICMP data payload** to carry hidden data (e.g., TCP, HTTP, or SSH).
- Custom ICMP packets may be **crafted to look legitimate** (e.g., 64 bytes).
- Some networks **block custom ICMP packets** or require admin rights to send them.

### Detection Indicators:
- **High volume** of ICMP traffic
- **Anomalous packet sizes**
- **ICMP packets at unusual times**
- Payload analysis showing **non-standard** behavior

## ðŸŽ¯ Story: Echoes in the Tunnel

Late at night, the SOC was quietâ€”too quiet. Vikram, the on-call analyst, was casually watching a dashboard when a Zeek alert blinked into life.

> **"High-frequency ICMP Echo Requests from Host-192.168.5.24 to 10.0.3.10"**

ICMP? Pings? Nothing unusualâ€”on the surface.

Still, something felt off. He opened a **packet capture** on the host's traffic and looked closer.

The ICMP packets werenâ€™t the usual 64 bytes. Some were **512 bytes**, some **1024**. He checked the payload... it was filled with hex gibberish. But the volume and frequency? It was like Morse code in the Matrix.

He ran a **payload entropy check** and spotted a high level of randomnessâ€”exactly the kind you see in **encrypted communications**.

> ICMP â‰  chatty. ICMP â‰  encrypted.

He remembered a training session: *â€œIf you see large, frequent ICMP echoes with payloadsâ€”itâ€™s probably not a ping.â€*

Pivoting to the endpoint, he found a **PowerShell script** left in `%Temp%`â€”disguised as a cleanup script. Inside, a function called `Send-ICMP-Data`. His suspicion confirmed: **ICMP Tunneling for data exfiltration**.

The attacker had breached a low-privilege account and was sending files chunk-by-chunk in ICMP packetsâ€”flying under the radar of firewalls and proxies.

Vikram immediately isolated the device, sent an IOC blast, and updated the network detection rules.

Another silent attack, blocked by someone who listened to the network's whispers.



## ðŸŒ DNS Analysis

**DNS (Domain Name System)** translates domain names into IP addresses.

### Legitimate Use:
- Web browsing
- App service resolution
- Email routing

### Malicious Use:
- **Data exfiltration**
- **Command & Control** via DNS queries

### DNS Tunnelling in a Nutshell:
- Starts after **malware** or **exploit-based intrusion**.
- Malware sends **crafted DNS queries** to a C2 server.
- Subdomains encode commands or data.

#### Example:
- encoded-commands.maliciousdomain.com
- Server decodes and replies with **malicious instructions**.
- Often **bypasses firewalls** because DNS is trusted and not inspected deeply.

### Detection Indicators:
- **Unusually long DNS queries**
- **Frequent queries to rare domains**
- DNS requests to **suspicious subdomains**
- **Encoded patterns** in FQDNs

## ðŸ” Analyst Actions

1. **Know the Baseline:** What is normal traffic in your environment?
2. **Monitor Packet Lengths:** Especially for ICMP and DNS.
3. **Use Threat Feeds & Correlation:** Integrate MISP or SIEM for automated anomaly detection.
4. **Escalate Early:** Any deviation in pattern is worth investigating.

## ðŸŽ¯ Story: The Hidden Signal in the Noise

It was a quiet Tuesday evening at the SOC. Aarya, a junior security analyst, had just finished reviewing firewall logs and was sipping her second coffee when the DNS logs lit up with something... odd.

She noticed a series of unusually **long DNS queries** being made from a single host:  
`g7he3j29f92bx7e9z6a0.examplemaliciousdomain.com`

Aarya raised an eyebrow. These werenâ€™t your usual `cdn.cloudflare.com` or `api.microsoft.com`. These looked... encoded.

She pivoted to the endpoint logs. The host in question belonged to the HR internâ€™s laptop, idle for hours. Yet, DNS queries were being fired every 20 secondsâ€”like clockwork.

She quickly fired up **Wireshark** and filtered for `dns.qry.name contains "examplemaliciousdomain.com"`.

Boom. A pattern emerged.

She grabbed a snippet of the encoded subdomain and ran it through a base64 decoder.  
Result: `ls -la /Users/`

**Command and Control.**

Malware had been silently using DNS tunnelling to receive commands from a remote server. No IP address connections, no traditional signaturesâ€”just stealth.

Aarya immediately flagged the host for isolation and alerted the incident response team. Thanks to her vigilance and her habit of always "checking the noise," a covert data breach attempt was stopped cold.

> _"In the world of security, sometimes the quietest protocols speak the loudest."_

----
# ðŸ›°ï¸ Cleartext Protocol Analysis

## ðŸ”“ FTP Analysis

File Transfer Protocol (FTP) is designed to transfer files with ease, focusing on simplicity rather than security. As a result, using FTP in unsecured environments can lead to various security issues.

### âš ï¸ Security Risks of FTP

- Man-in-the-middle (MITM) attacks  
- Credential theft and unauthorised access  
- Phishing  
- Malware planting  
- Data exfiltration

## ðŸ§ª FTP Analysis in a Nutshell (with Wireshark)
![[Pasted image 20250608122540.png]]![[Pasted image 20250608122618.png]]
![[Pasted image 20250608122717.png]]

## ðŸ“– Mini-Story: â€œFTP Tells a Storyâ€

> You load a PCAP into Wireshark. The logs begin simpleâ€”`USER`, `PASS`, followed by repeated `530` errors. A brute-force attempt, clearly.
> 
> Then, a `230`. Theyâ€™re in. A `227` shows passive mode is enabled. The attacker uses `LIST` and starts exfiltrating. The attack is no longer hypothetical.
> 
> FTP, in its simplicity, tells a full story. All it takes is the right lens and a sharp analyst to read it.

---
# ðŸŒ Cleartext Protocol Analysis

## ðŸ“¡ HTTP Analysis

**Hypertext Transfer Protocol (HTTP)** is a cleartext-based, request-response, and client-server protocol. It is the standard mechanism used to request and serve web pages. Since HTTP traffic is unencrypted and typically allowed by default through most firewalls, it is essential for traffic analysis.

### âš ï¸ Security Risks & Threat Detection via HTTP

- ðŸ§ª Phishing pages  
- ðŸ›¡ï¸ Web attacks (e.g., XSS, SQLi, etc.)  
- ðŸ“¤ Data exfiltration  
- ðŸ‘¾ Command and Control (C2) communications  

HTTP traffic can expose all of this, especially when adversaries use it to blend malicious traffic into normal-looking web activity.

## ðŸ” User-Agent Analysis

Adversaries often attempt to **blend in** by mimicking legitimate browser behavior. One of the commonly spoofed fields is the `User-Agent`.
- The `User-Agent` string identifies the browser, OS, and device making the HTTP request.

### ðŸ§  Analyst Tips

- Donâ€™t **whitelist** a user-agent blindly. Even well-known ones (e.g., Chrome or Firefox) can be spoofed.
- Use the `user-agent` field as an **indicator**, not a confirmation.
- Validate user-agent strings with online sources to verify their legitimacy and compare against known defaults.

### ðŸ“˜ Common Anomalies in User-Agent Analysis

- Obscure or malformed user-agent strings.
- Scripts or tools (like `curl`, `wget`, `python-requests`) instead of browsers.
- Mismatches between OS type and browser.
- Excessively rare or outdated browser versions.
- User-agents used repeatedly with suspicious request patterns.

### ðŸ§ª Example Wireshark Filter for HTTP User-Agent

```wireshark
http.user_agent contains "curl"
http.user_agent contains "python"
```

## ðŸ§° Bonus Wireshark Filters for HTTP Hunting


```wireshark
http.request.uri contains ".php" 
http.request.method == "POST" 
http contains "cmd=" || http contains "exec=" 
http.user_agent contains "bot" 
http.request.full_uri contains "suspiciousdomain.com"
```

## ðŸ§  Mini-Story: â€œThe User-Agent That Liedâ€

> A user-agent says itâ€™s Chrome 113 on Windows 10. Seems fine.
> But something's oddâ€”every 10 seconds, a GET request hits the same rare endpoint: `/stealth/logs/pull`.
> You dig deeper. The headers are too clean, the frequency too robotic.
> It wasnâ€™t a browserâ€”it was a Python script. The attacker wanted to look like you and me.
> But the user-agentâ€¦ it lied.

___
# ðŸ” Decrypting HTTPS Traffic

## ðŸŒ What is HTTPS?

When investigating web traffic, analysts often come across **encrypted traffic** caused by the **HTTPS** protocol. HTTPS (Hypertext Transfer Protocol Secure) uses **TLS (Transport Layer Security)** to encrypt communications, protecting against:

- ðŸ•µï¸â€â™‚ï¸ Spoofing  
- ðŸ”Ž Sniffing  
- ðŸ” Interception

While HTTPS enhances security for legitimate use, attackers **also use HTTPS** to hide malicious content and command & control traffic. Therefore, **decrypting HTTPS traffic** is a crucial skill for security analysts.


## ðŸ§© Why Can't We See HTTPS Data?

Since TLS encrypts HTTP payloads:
- The packets show up in different colours in Wireshark.
- The actual content (e.g., **URL paths, parameters, server response**) is **unreadable**.
- Only TLS handshake metadata (e.g., `Client Hello`, `Server Hello`) is visible without decryption.

## ðŸ¤ TLS Handshake Overview

TLS uses a handshake process similar to TCP's three-way handshake. Key stages:

- `Client Hello` â€” initiates connection
- `Server Hello` â€” responds with certificate and key exchange

### ðŸ” Wireshark Filters for TLS Handshake

```wireshark
# Shows **Client Hello** packets
(http.request or tls.handshake.type == 1) and !(ssdp)

# Shows **Server Hello** packets
(http.request or tls.handshake.type == 2) and !(ssdp)
```

## ðŸ”‘ Using Key Log Files to Decrypt HTTPS

To decrypt HTTPS traffic in Wireshark, you need a **key log file**. This file stores session-specific keys that TLS uses to encrypt data.

### ðŸ“ What is a Key Log File?

- A plain text file that holds **pre-master secrets** generated during the TLS handshake.
- Generated **per session**.
- Must be captured **during** the session to be useful.

## ðŸŒ Supported Browsers for Key Logging

Both **Chrome** and **Firefox** allow dumping key logs to a file
### ðŸ› ï¸ How to Generate SSLKEYLOGFILE

1. **Set Environment Variable**:
   **Linux/macOS**:
```bash
export SSLKEYLOGFILE=~/Desktop/sslkeys.log
```

**Windows (CMD)**:

```bash
set SSLKEYLOGFILE=C:\Users\YourName\Desktop\sslkeys.log
```

2. **Restart your browser** (Chrome or Firefox).
3. Browse the site to generate encrypted traffic.
4. The browser writes TLS session keys to the file.
5. Load this key log file into Wireshark.
    
## ðŸ§° How to Use Key Log File in Wireshark

### ðŸ”§ Option 1: Via Preferences

1. Go to **Edit â†’ Preferences â†’ Protocols â†’ TLS**
2. Set the **(Pre)-Master-Secret log filename** to your key log file.
    
### ðŸ”§ Option 2: Right-click on a TLS packet â†’ Protocol Preferences â†’ Edit TLS Preferences


## ðŸš« Limitations

- You **must** have captured the traffic **while** the key log file was being generated.
- Retrospective decryption is **not possible** if the keys werenâ€™t captured.
- **Forward secrecy (e.g., using ECDHE)** may prevent some sessions from being decrypted even with the key log.

> ðŸŽ¯ **Pro Tip**: Always generate a key log file while capturing traffic if you plan to analyze HTTPS sessions in depth. Keep the browser open and use a clean test system if needed.

.
## ðŸ§  Mini-Story: "The Encrypted Exfiltration"

> Your captured PCAP looks clean. No strange domains, no huge uploads. Just regular HTTPS.
> But your gut says something's off. You remember to check the key log file from that Firefox session.
> You load it in Wireshark. Boom ðŸ’¥ â€” the "innocent" POST to `https://updates.example.com` is actually dumping sensitive credentials.
> The attacker used HTTPS to hide it. But your decryption exposed it.
> The lesson? **Encryption hides secrets. But so does the truth.**


